{"version":3,"file":"common.c208d71c89779a55.js","mappings":"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","names":["proxyMarker","Symbol","createEndpoint","releaseProxy","finalizer","throwMarker","isObject","val","transferHandlers","Map","canHandle","serialize","obj","port1","port2","MessageChannel","expose","deserialize","port","start","wrap","value","serialized","Error","isError","message","name","stack","Object","assign","ep","globalThis","allowedOrigins","addEventListener","callback","ev","data","isAllowedOrigin","origin","allowedOrigin","RegExp","test","console","warn","id","type","path","argumentList","map","fromWireValue","returnValue","parent","slice","reduce","prop","rawValue","apply","proxy","transfer","transfers","transferCache","set","undefined","d","Promise","resolve","catch","then","wireValue","transferables","toWireValue","postMessage","removeEventListener","closeEndPoint","error","TypeError","endpoint","isMessagePort","constructor","close","target","createProxy","throwIfProxyReleased","isReleased","releaseEndpoint","requestResponseMessage","proxyCounter","WeakMap","proxyFinalizers","FinalizationRegistry","newCount","get","isProxyReleased","Proxy","_target","unregisterProxy","unregister","length","r","p","toString","bind","_thisArg","rawArgumentList","last","processArguments","construct","registerProxy","register","myFlat","arr","Array","prototype","concat","processed","v","L","handler","serializedValue","msg","generateUUID","fill","Math","floor","random","Number","MAX_SAFE_INTEGER","join","l","asyncGeneratorStep","gen","reject","_next","_throw","key","arg","info","done","_asyncToGenerator","fn","self","this","args","arguments","err"],"sourceRoot":"webpack:///","sources":["./node_modules/comlink/dist/esm/comlink.mjs","./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js"],"sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst proxyMarker = Symbol(\"Comlink.proxy\");\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\nconst finalizer = Symbol(\"Comlink.finalizer\");\nconst throwMarker = Symbol(\"Comlink.thrown\");\nconst isObject = (val) => (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nconst proxyTransferHandler = {\n    canHandle: (val) => isObject(val) && val[proxyMarker],\n    serialize(obj) {\n        const { port1, port2 } = new MessageChannel();\n        expose(obj, port1);\n        return [port2, [port2]];\n    },\n    deserialize(port) {\n        port.start();\n        return wrap(port);\n    },\n};\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nconst throwTransferHandler = {\n    canHandle: (value) => isObject(value) && throwMarker in value,\n    serialize({ value }) {\n        let serialized;\n        if (value instanceof Error) {\n            serialized = {\n                isError: true,\n                value: {\n                    message: value.message,\n                    name: value.name,\n                    stack: value.stack,\n                },\n            };\n        }\n        else {\n            serialized = { isError: false, value };\n        }\n        return [serialized, []];\n    },\n    deserialize(serialized) {\n        if (serialized.isError) {\n            throw Object.assign(new Error(serialized.value.message), serialized.value);\n        }\n        throw serialized.value;\n    },\n};\n/**\n * Allows customizing the serialization of certain values.\n */\nconst transferHandlers = new Map([\n    [\"proxy\", proxyTransferHandler],\n    [\"throw\", throwTransferHandler],\n]);\nfunction isAllowedOrigin(allowedOrigins, origin) {\n    for (const allowedOrigin of allowedOrigins) {\n        if (origin === allowedOrigin || allowedOrigin === \"*\") {\n            return true;\n        }\n        if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction expose(obj, ep = globalThis, allowedOrigins = [\"*\"]) {\n    ep.addEventListener(\"message\", function callback(ev) {\n        if (!ev || !ev.data) {\n            return;\n        }\n        if (!isAllowedOrigin(allowedOrigins, ev.origin)) {\n            console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);\n            return;\n        }\n        const { id, type, path } = Object.assign({ path: [] }, ev.data);\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n        let returnValue;\n        try {\n            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n            const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n            switch (type) {\n                case \"GET\" /* MessageType.GET */:\n                    {\n                        returnValue = rawValue;\n                    }\n                    break;\n                case \"SET\" /* MessageType.SET */:\n                    {\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n                        returnValue = true;\n                    }\n                    break;\n                case \"APPLY\" /* MessageType.APPLY */:\n                    {\n                        returnValue = rawValue.apply(parent, argumentList);\n                    }\n                    break;\n                case \"CONSTRUCT\" /* MessageType.CONSTRUCT */:\n                    {\n                        const value = new rawValue(...argumentList);\n                        returnValue = proxy(value);\n                    }\n                    break;\n                case \"ENDPOINT\" /* MessageType.ENDPOINT */:\n                    {\n                        const { port1, port2 } = new MessageChannel();\n                        expose(obj, port2);\n                        returnValue = transfer(port1, [port1]);\n                    }\n                    break;\n                case \"RELEASE\" /* MessageType.RELEASE */:\n                    {\n                        returnValue = undefined;\n                    }\n                    break;\n                default:\n                    return;\n            }\n        }\n        catch (value) {\n            returnValue = { value, [throwMarker]: 0 };\n        }\n        Promise.resolve(returnValue)\n            .catch((value) => {\n            return { value, [throwMarker]: 0 };\n        })\n            .then((returnValue) => {\n            const [wireValue, transferables] = toWireValue(returnValue);\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n            if (type === \"RELEASE\" /* MessageType.RELEASE */) {\n                // detach and deactive after sending release response above.\n                ep.removeEventListener(\"message\", callback);\n                closeEndPoint(ep);\n                if (finalizer in obj && typeof obj[finalizer] === \"function\") {\n                    obj[finalizer]();\n                }\n            }\n        })\n            .catch((error) => {\n            // Send Serialization Error To Caller\n            const [wireValue, transferables] = toWireValue({\n                value: new TypeError(\"Unserializable return value\"),\n                [throwMarker]: 0,\n            });\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n        });\n    });\n    if (ep.start) {\n        ep.start();\n    }\n}\nfunction isMessagePort(endpoint) {\n    return endpoint.constructor.name === \"MessagePort\";\n}\nfunction closeEndPoint(endpoint) {\n    if (isMessagePort(endpoint))\n        endpoint.close();\n}\nfunction wrap(ep, target) {\n    return createProxy(ep, [], target);\n}\nfunction throwIfProxyReleased(isReleased) {\n    if (isReleased) {\n        throw new Error(\"Proxy has been released and is not useable\");\n    }\n}\nfunction releaseEndpoint(ep) {\n    return requestResponseMessage(ep, {\n        type: \"RELEASE\" /* MessageType.RELEASE */,\n    }).then(() => {\n        closeEndPoint(ep);\n    });\n}\nconst proxyCounter = new WeakMap();\nconst proxyFinalizers = \"FinalizationRegistry\" in globalThis &&\n    new FinalizationRegistry((ep) => {\n        const newCount = (proxyCounter.get(ep) || 0) - 1;\n        proxyCounter.set(ep, newCount);\n        if (newCount === 0) {\n            releaseEndpoint(ep);\n        }\n    });\nfunction registerProxy(proxy, ep) {\n    const newCount = (proxyCounter.get(ep) || 0) + 1;\n    proxyCounter.set(ep, newCount);\n    if (proxyFinalizers) {\n        proxyFinalizers.register(proxy, ep, proxy);\n    }\n}\nfunction unregisterProxy(proxy) {\n    if (proxyFinalizers) {\n        proxyFinalizers.unregister(proxy);\n    }\n}\nfunction createProxy(ep, path = [], target = function () { }) {\n    let isProxyReleased = false;\n    const proxy = new Proxy(target, {\n        get(_target, prop) {\n            throwIfProxyReleased(isProxyReleased);\n            if (prop === releaseProxy) {\n                return () => {\n                    unregisterProxy(proxy);\n                    releaseEndpoint(ep);\n                    isProxyReleased = true;\n                };\n            }\n            if (prop === \"then\") {\n                if (path.length === 0) {\n                    return { then: () => proxy };\n                }\n                const r = requestResponseMessage(ep, {\n                    type: \"GET\" /* MessageType.GET */,\n                    path: path.map((p) => p.toString()),\n                }).then(fromWireValue);\n                return r.then.bind(r);\n            }\n            return createProxy(ep, [...path, prop]);\n        },\n        set(_target, prop, rawValue) {\n            throwIfProxyReleased(isProxyReleased);\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n            // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\n            const [value, transferables] = toWireValue(rawValue);\n            return requestResponseMessage(ep, {\n                type: \"SET\" /* MessageType.SET */,\n                path: [...path, prop].map((p) => p.toString()),\n                value,\n            }, transferables).then(fromWireValue);\n        },\n        apply(_target, _thisArg, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const last = path[path.length - 1];\n            if (last === createEndpoint) {\n                return requestResponseMessage(ep, {\n                    type: \"ENDPOINT\" /* MessageType.ENDPOINT */,\n                }).then(fromWireValue);\n            }\n            // We just pretend that `bind()` didn’t happen.\n            if (last === \"bind\") {\n                return createProxy(ep, path.slice(0, -1));\n            }\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, {\n                type: \"APPLY\" /* MessageType.APPLY */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n        construct(_target, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, {\n                type: \"CONSTRUCT\" /* MessageType.CONSTRUCT */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n    });\n    registerProxy(proxy, ep);\n    return proxy;\n}\nfunction myFlat(arr) {\n    return Array.prototype.concat.apply([], arr);\n}\nfunction processArguments(argumentList) {\n    const processed = argumentList.map(toWireValue);\n    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\nconst transferCache = new WeakMap();\nfunction transfer(obj, transfers) {\n    transferCache.set(obj, transfers);\n    return obj;\n}\nfunction proxy(obj) {\n    return Object.assign(obj, { [proxyMarker]: true });\n}\nfunction windowEndpoint(w, context = globalThis, targetOrigin = \"*\") {\n    return {\n        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\n        addEventListener: context.addEventListener.bind(context),\n        removeEventListener: context.removeEventListener.bind(context),\n    };\n}\nfunction toWireValue(value) {\n    for (const [name, handler] of transferHandlers) {\n        if (handler.canHandle(value)) {\n            const [serializedValue, transferables] = handler.serialize(value);\n            return [\n                {\n                    type: \"HANDLER\" /* WireValueType.HANDLER */,\n                    name,\n                    value: serializedValue,\n                },\n                transferables,\n            ];\n        }\n    }\n    return [\n        {\n            type: \"RAW\" /* WireValueType.RAW */,\n            value,\n        },\n        transferCache.get(value) || [],\n    ];\n}\nfunction fromWireValue(value) {\n    switch (value.type) {\n        case \"HANDLER\" /* WireValueType.HANDLER */:\n            return transferHandlers.get(value.name).deserialize(value.value);\n        case \"RAW\" /* WireValueType.RAW */:\n            return value.value;\n    }\n}\nfunction requestResponseMessage(ep, msg, transfers) {\n    return new Promise((resolve) => {\n        const id = generateUUID();\n        ep.addEventListener(\"message\", function l(ev) {\n            if (!ev.data || !ev.data.id || ev.data.id !== id) {\n                return;\n            }\n            ep.removeEventListener(\"message\", l);\n            resolve(ev.data);\n        });\n        if (ep.start) {\n            ep.start();\n        }\n        ep.postMessage(Object.assign({ id }, msg), transfers);\n    });\n}\nfunction generateUUID() {\n    return new Array(4)\n        .fill(0)\n        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n        .join(\"-\");\n}\n\nexport { createEndpoint, expose, finalizer, proxy, proxyMarker, releaseProxy, transfer, transferHandlers, windowEndpoint, wrap };\n","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\nexport default function _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n      args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n      _next(undefined);\n    });\n  };\n}"],"x_google_ignoreList":[0,1]}